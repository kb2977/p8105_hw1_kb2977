---
title: "Homework 1"
output: github_document
---

##Sept 21, 2018
##Francois Ban

###Problem 1

```{r loading_tidyverse, include = FALSE}
library(tidyverse)

set.seed(1)
```

Below is a dataframe containing four different vectors:

```{r prob1_df}
prob1_df = tibble(
  rand_samp = runif(10, min = 0, max = 5),
  log_vec = rand_samp > 2,
  char_vec = LETTERS[1:10],
  fac_vec = factor(LETTERS[1:10])
)
```
  
Below is the mean of each variable in the dataframe (prob1_df).

```{r means}

mean_rand_samp <- mean(prob1_df$rand_samp)
mean_log_vec <- mean(prob1_df$log_vec)
mean_char_vec <- mean(prob1_df$char_vec)
mean_fac_vec <- mean(prob1_df$fac_vec)
```

After taking the mean of each variable in my dataframe, it is evident that mean_rand_samp and mean_log_vec works because the arguments are numeric whereas mean_char_vec and mean_fac_vec are not.

Bellow is a code chunk that applies the as.numeric function to the logical, character, and factor variables.

```{r convert_to_num, eval = FALSE}

as.numeric(prob1_df$rand_samp)
as.numeric(prob1_df$log_vec)
as.numeric(prob1_df$char_vec)
as.numeric(prob1_df$fac_vec)
```

It is not possible to convert a character variable to a numeric vector which is why the output is NA for "as.numeric(char_vec)". It is possible to convert a factor vector to a numeric vector because the factor vector are categorical variables that assigns an integer to every unique level of a factor vector.

In this code chunk, the character variable (char_vec) is converted from character to factor to numeric; similarly, convert my factor variable (fac_vec) is converted from factor to character to numeric.

```{r convert_char_fac}

char_to_fac <- as.factor(prob1_df$char_vec)
as.numeric(char_to_fac)

fac_to_char <- as.character(prob1_df$fac_vec)
as.numeric(fac_to_char)
```

It is possible to convert a character vector to a factor vector to a numeric vector but it is not possible to convert a factor vector to a character vector to a numeric vector.

###Problem 2

Below is a dataframe for Problem 2:
  
```{r prob2_df}

set.seed(1)

prob2_df = tibble(
  x = rnorm(1000),
  y = rnorm(1000),
  log_vec = (x + y > 0),
  num_vec = as.numeric(log_vec),
  fac_vec = as.factor(log_vec)
)
```

My vector created above has a dataset size of `r length(prob2_df)` columns and `r length(prob2_df$x)` rows, a mean of `r mean(prob2_df$x)`, a median of `r median(prob2_df$x)`, and a proportion of cases `r mean(prob2_df$log_vec)`.

Below is a scatterplot of x and y that colors the points based on the logical variable:
  
```{r sp_log_vec}

plot_1 = ggplot(prob2_df, aes(x = x, y = y)) +
  geom_point(aes(color = prob2_df$log_vec))
plot_1
```

The red points are the x and y values that do not meet the log_vec statement (FALSE) whereas the blue points are the x and y values that do meet the log_vec statement (TRUE).

Below is a scatterplot of x and y that colors the points based on the numeric variable:
  
```{r sp_num_vec}

plot_2 = ggplot(prob2_df, aes(x = x, y = y)) +
  geom_point(aes(color = prob2_df$num_vec))
plot_2
```
The dark blue points represent the points when num_vec = 0 (FALSE) and the light blue point represent the values in which num_vec = 1 (TRUE).

Below is a scatterplot of x and y that colors the points based on the factor variable: 
  
```{r sp_fac_vec}

plot_3 = ggplot(prob2_df, aes(x = x, y = y)) +
  geom_point(aes(color = prob2_df$fac_vec,))
plot_3
```
The blue points represent when fac_vec = TRUE and the red points represent when fac_vec = FALSE. This scale is different from the numeric scatterplot (sp_num_vec) because there are only a set of values that fac_vec can take (in this case, TRUE or FALSE) whereas there are an infinite number of values that a numeric vector can take.

Exporting the first scatterplot (plot_1) to my project directory.

```{r}
ggsave("scatterplot_log_vec.pdf", plot = plot_1, height = 4, width = 6)
```